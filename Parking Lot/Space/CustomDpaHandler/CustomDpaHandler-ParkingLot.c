// **************************************************************************
//   Custom DPA Handler code - User peripheral check input		 			*
// **************************************************************************
//
// Code was originally written by IQRF Tech s.r.o.
// Changes are made by Simen Stensås and Kjell Kirkaune, for ELE3391 Elektro prosjekt in the fall of 2019 at NTNU in Gjøvik.
// The unchanged version of this code can be found at downloaded IQRF resources folder (downloaded at IQRF's website as .zip).
//
// Code tested on: TR-72DA, on OS 4.03 and DPA 4.03. No guarantee to work on future versions, minor changes may be done.
//
// *********************************************************************


// Default IQRF include (modify the path according to your setup)
#include "folder\to\IQRF.h"

// Default DPA header (modify the path according to your setup)
#include "folder\to\DPA.h"
// Default Custom DPA Handler header (modify the path according to your setup)
#include "folder\to\DPAcustomHandler.h"


// Port definitions
#define PARKING			!PORTC.3			// See if space is taken


// Bit-shift function
void toggle(uns8 comb);

uns8 spaceTaken;


bit CustomDpaHandler()
//############################################################################################
{
  // Handler presence mark
  clrwdt();

  // Detect DPA event to handle (unused event handlers can be commented out or even deleted)
  switch ( GetDpaEvent() )
  {
	  
#ifdef DpaEvent_Interrupt
    // -------------------------------------------------
    case DpaEvent_Interrupt:
      // Do an extra quick background interrupt work
      // ! The time spent handling this event is critical.If there is no interrupt to handle return immediately otherwise keep the code as fast as possible.
      // ! Make sure the event is the 1st case in the main switch statement at the handler routine.This ensures that the event is handled as the 1st one.
      // ! It is desirable that this event is handled with immediate return even if it is not used by the custom handler because the Interrupt event is raised on every MCU interrupt and the “empty” return handler ensures the shortest possible interrupt routine response time.
      // ! Only global variables or local ones marked by static keyword can be used to allow reentrancy.
      // ! Make sure race condition does not occur when accessing those variables at other places.
      // ! Make sure( inspect.lst file generated by C compiler ) compiler does not create any hidden temporary local variable( occurs when using division, multiplication or bit shifts ) at the event handler code.The name of such variable is usually Cnumbercnt.
      // ! Do not call any OS functions except setINDFx().
      // ! Do not use any OS variables especially for writing access.
      // ! All above rules apply also to any other function being called from the event handler code, although calling any function from Interrupt event is not recommended because of additional MCU stack usage.

DpaHandleReturnTRUE:
      return TRUE;
#endif

	  // -------------------------------------------------
	case DpaEvent_Idle:
    {
		clrwdt();
		
		// Check if space is taken
		if ( PARKING )
		{
			spaceTaken = 1;
		}
		else
		{
			spaceTaken = 0;
		}
		
		return Carry;
    }
    break;

	  // -------------------------------------------------
	case DpaEvent_Reset:

        // Input from hall-effect sensor (active high means no car)
        TRISC.3 = 1;			// PIN 6: MAIN		Register RC3 - (input)
        
		break;

	  // -------------------------------------------------
	case DpaEvent_Init:
		// Do a one time initialization work before main loop starts
		
		break;

	  // -------------------------------------------------
	case DpaEvent_DpaRequest:
	  // Called to interpret DPA request for peripherals
	  // -------------------------------------------------
	  // Peripheral enumeration
	  if ( IsDpaEnumPeripheralsRequest() )
	  {
		_DpaMessage.EnumPeripheralsAnswer.UserPerNr = 1; // ?
		_DpaMessage.EnumPeripheralsAnswer.HWPID = 0x000F; // ????
		_DpaMessage.EnumPeripheralsAnswer.HWPIDver = 0xabcd; // ????
		goto DpaHandleReturnTRUE;
	  }
	  // -------------------------------------------------
	  // Get information about peripheral
	  else if ( IsDpaPeripheralInfoRequest() )
	  {
		if ( _PNUM == PNUM_USER + 3 ) // ?
		{
		  _DpaMessage.PeripheralInfoAnswer.PerT = PERIPHERAL_TYPE_USER_AREA; // PERIPHERAL_TYPE_?
		  _DpaMessage.PeripheralInfoAnswer.PerTE = PERIPHERAL_TYPE_EXTENDED_WRITE; // PERIPHERAL_TYPE_EXTENDED_?
		  _DpaMessage.PeripheralInfoAnswer.Par1 = 0; // ?
		  _DpaMessage.PeripheralInfoAnswer.Par2 = 0; // ?
		  goto DpaHandleReturnTRUE;
		}

		break;
	  }
	  // -------------------------------------------------
	  else
	  {
		// Handle peripheral command
		if ( _PNUM == PNUM_USER + 3 ) // 23
		{

            // Check command
			if ( _PCMD != 0 )
				DpaApiReturnPeripheralError( ERROR_PCMD );

			// Check data length
			if ( _DpaDataLength != 0 )
				DpaApiReturnPeripheralError( ERROR_DATA_LEN );
			
			clrwdt();
			
			if( spaceTaken )
			{
				_DpaMessage.Response.PData[0] = 0xFF;
			}
			else
			{
				_DpaMessage.Response.PData[0] = 0x00;
			}
			
			_DpaDataLength = sizeof( uns8 );
          
			goto DpaHandleReturnTRUE;
		}
	  }

	  break;
  }
DpaHandleReturnFALSE:
  return FALSE;
}

//############################################################################################
// Default Custom DPA Handler header; 2nd include to implement Code bumper to detect too long code of the Custom DPA Handler (modify the path according to your setup) 
#include "folder\to\DPAcustomHandler.h"
//############################################################################################
