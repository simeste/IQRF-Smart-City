// **************************************************************************
//   Custom DPA Handler code example - User peripheral implementation - PWM *
// **************************************************************************
//
// Code was originally written by IQRF Tech s.r.o.
// Changes are made by Simen Stensås and Kjell Kirkaune, for ELE3391 Elektro prosjekt in the fall of 2019 at NTNU in Gjøvik.
// The unchanged version of this code can be found at downloaded IQRF resources folder (downloaded at IQRF's website as .zip).
//
// Code tested on: TR-72DA, on OS 4.03 and DPA 4.03. No guarantee to work on future versions, minor changes may be done.
//
// *********************************************************************


//############################################################################################

// This example demonstrates usage of PWM and Timer at same time
// It implements one user peripheral PNUM=0x20, PCMD=0x00
// Data contains list of commands at the following format
// 0x00, PWM
//  Sets 8bit PWM duty cycle to value "PWM"
// 0x01, loopLow8, loopHigh8, pwmAddlow8, pwmAddhigh8
//  Adds 16bit "pwmAdd" value divided by 256 "loop" times. Time unit is approx 16 ms
// 0x02
//  Starts executing command from the beginning
// 0x03
//  Stops execution of commands

// This example works only at STD mode, not at LP mode

// Example data for PNUM=0x20, PCMD=0x00
// 0x00, 0x00,
//  - Sets PWM duty cycle to 0
// 0x01, 0x00, 0x01, 0x40, 0x00,
//  - Adds 0x0100 = 256 times every 16 ms value 0x0040 / 256 = 0.25 to the duty cycle
// 0x01, 0x00, 0x01, 0xC0, 0xFF,
//  - Adds 0x0100 = 256 times every 16 ms value 0xFFC0 / 256 = -0x0040 / 256 = -0.25 to the duty cycle
// 0x01, 0x80, 0x00, 0x00, 0x00,
//  - Adds 0x0800 = 128 times every 16 ms value 0 to the duty cycle (wait delay for approx 2 s)
// 0x02
//  - Starts again

// Default IQRF include (modify the path according to your setup)
#include "folder\to\IQRF.h"

// Default DPA header (modify the path according to your setup)
#include "folder\to\DPA.h"
// Default Custom DPA Handler header (modify the path according to your setup)
#include "folder\to\DPAcustomHandler.h"

// PWM commands
typedef enum
{
  CMD_SET_PWM = 0,
  CMD_CHANGE_PWM = 1,
  CMD_LOOP = 2,
  CMD_STOP = 3
};

//############################################################################################

// Must be the 1st defined function in the source code in order to be placed at the correct FLASH location!
//############################################################################################
bit CustomDpaHandler()
//############################################################################################
{
  // Handler presence mark
  clrwdt();

  // List of commands
  static uns8 Cmds[40];
  // Index of the next command
  static uns8 CmdsIndex;
  // Loop for changing  PWM
  static uns16 ChangePWMloop;
  // Value to add to PWM during change
  static uns16 ChangePWMadd;
  // Full 16b PWM duty cycle value, only higher part is used at MCU
  static uns16 CCPR3Lshadow;

  // Detect DPA event to handle
  switch ( GetDpaEvent() )
  {
    // -------------------------------------------------
    case DpaEvent_Interrupt:
      // Do an extra quick background interrupt work
      // ! The time spent handling this event is critical.If there is no interrupt to handle return immediately otherwise keep the code as fast as possible.
      // ! Make sure the event is the 1st case in the main switch statement at the handler routine.This ensures that the event is handled as the 1st one.
      // ! It is desirable that this event is handled with immediate return even if it is not used by the custom handler because the Interrupt event is raised on every MCU interrupt and the “empty” return handler ensures the shortest possible interrupt routine response time.
      // ! Only global variables or local ones marked by static keyword can be used to allow reentrancy.
      // ! Make sure race condition does not occur when accessing those variables at other places.
      // ! Make sure( inspect.lst file generated by C compiler ) compiler does not create any hidden temporary local variable( occurs when using division, multiplication or bit shifts ) at the event handler code.The name of such variable is usually Cnumbercnt.
      // ! Do not call any OS functions except setINDFx().
      // ! Do not use any OS variables especially for writing access.
      // ! All above rules apply also to any other function being called from the event handler code, although calling any function from Interrupt event is not recommended because of additional MCU stack usage.

      //  If TMR6 interrupt occurred
      if ( TMR6IF )
      {
        // Unmask interrupt
        TMR6IF = 0;

        // Changing PWM?
        if ( ChangePWMloop != 0 )
        {
          // Decrease loop
          ChangePWMloop--;
          // Add PWM
          CCPR3Lshadow += ChangePWMadd;
          // Copy to MCU
          CCPR3L = CCPR3Lshadow.high8;
        }
        else
        {
          // Get command pointer
          FSR0 = Cmds + CmdsIndex;
          switch ( FSR0[0] )
          {
            // Set PWM
            case CMD_SET_PWM:
              // Next cmd
              CmdsIndex += 1 + 1;
              // Get value
              CCPR3Lshadow.high8 = CCPR3L = FSR0[1];
              CCPR3Lshadow.low8 = 0;
              break;

              // Change PWM
            case CMD_CHANGE_PWM:
              // Next cmd
              CmdsIndex += 1 + 4;
              // Get loop count
              ChangePWMloop.low8 = FSR0[1];
              ChangePWMloop.high8 = FSR0[2];
              // Get added value
              ChangePWMadd.low8 = FSR0[3];
              ChangePWMadd.high8 = FSR0[4];
              break;

              // Loop commands
            case CMD_LOOP:
              // Start from the 1st command
              CmdsIndex = 0;
              break;

              // Stop commands
            case CMD_STOP:
            default:
              break;
          }
        }
      }
      return Carry;

      // -------------------------------------------------
    case DpaEvent_Init:
      // Do a one time initialization work before main loop starts

      // Start with no commands
      Cmds[0] = CMD_STOP;
      // CmdsIndex = 0 // By C definition

      // Definitions used for TR72 having connected pins
#define _OUT_A5	TRISA.5
#define _OUT_B4	TRISB.4
#define _OUT_C6	TRISC.6
#define _PIN_C6	LATC.6

      // Read module info into bufferINFO
      moduleInfo();
      // TR module with connected pins?
      if ( bufferINFO[5].7 == 0 )
      {
        _OUT_A5 = 1;
        _OUT_B4 = 1;
      }

      // Single output; PxA modulated; PxB, PxC, PxD assigned as port pins
      // PWM mode: PxA, PxC active-high; PxB, PxD active-high
      CCP3CON = 0b00.00.1100;
      // PWM duty cycle
      CCPR3L = 0;
      // Period
      PR6 = 0xff;
      // CCP3 is based off Timer6 in PWM mode
      CCPTMRS0 = 0b00100000;
      // CCP3/P3A function is CCP3
      CCP3SEL = 0;
#if F_OSC == 16000000
      // Prescaler 16, Postscaler 8, 16 * 16 * 256 = 65536 = 61 Hz = 16 ms @16MHz
      // TMR6 on
      T6CON = 0b0.1111.1.10;
#else
#error Unsupported oscillator frequency
#endif

      // TMR6 interrupt
      TMR6IE = 1;
      // Set output
      _OUT_C6 = 0;

      break;

      // -------------------------------------------------
    case DpaEvent_AfterSleep:
      // Called on wake-up from sleep
      TMR6IE = TRUE;
      TMR6ON = TRUE;
      break;

      // -------------------------------------------------
    case DpaEvent_BeforeSleep:
      // Called before going to sleep	(the same handling as DpaEvent_DisableInterrupts event)

      // -------------------------------------------------
    case DpaEvent_DisableInterrupts:
      // Called when device needs all hardware interrupts to be disabled (before Reset, Restart, LoadCode, Remove bond, and Run RFPGM)
      // Must not use TMR6 any more
      TMR6ON = FALSE;
      TMR6IE = FALSE;
      _PIN_C6 = FALSE;
      break;

      // -------------------------------------------------
    case DpaEvent_DpaRequest:
      // Called to interpret DPA request for peripherals
      // -------------------------------------------------
      // Peripheral enumeration
      if ( IsDpaEnumPeripheralsRequest() )
      {
        // We implement 1 user peripheral
        _DpaMessage.EnumPeripheralsAnswer.UserPerNr = 1;
        FlagUserPer( _DpaMessage.EnumPeripheralsAnswer.UserPer, PNUM_USER + 0 );
        _DpaMessage.EnumPeripheralsAnswer.HWPID = 0x000F;
        _DpaMessage.EnumPeripheralsAnswer.HWPIDver = 0xFeFe;

DpaHandleReturnTRUE:
        return TRUE;
      }
      // -------------------------------------------------
      // Get information about peripheral
      else if ( IsDpaPeripheralInfoRequest() )
      {
        if ( _PNUM == PNUM_USER + 0 )
        {
          _DpaMessage.PeripheralInfoAnswer.PerT = PERIPHERAL_TYPE_USER_AREA;
          _DpaMessage.PeripheralInfoAnswer.PerTE = PERIPHERAL_TYPE_EXTENDED_WRITE;
          goto DpaHandleReturnTRUE;
        }

        break;
      }
      // -------------------------------------------------
      else
      {
        // Handle peripheral command
        if ( _PNUM == PNUM_USER + 0 )
        {
          // Check command
          if ( _PCMD != 0 )
            DpaApiReturnPeripheralError( ERROR_PCMD );

          // Check data length
          if ( _DpaDataLength > ( sizeof( Cmds ) - 1 ) )
            DpaApiReturnPeripheralError( ERROR_DATA_LEN );

          // Copy commands and always append CMD_STOP for sure
          GIE = FALSE;
          copyMemoryBlock( _DpaMessage.Request.PData, Cmds, sizeof( Cmds ) - 1 );
          writeToRAM( Cmds + _DpaDataLength, CMD_STOP );
          // Start new commands
          CmdsIndex = 0;
          ChangePWMloop = 0;
          GIE = TRUE;

          // Write no error
          _DpaDataLength = 0;
          goto DpaHandleReturnTRUE;
        }
      }
  }

  return FALSE;
}

//############################################################################################
// Default Custom DPA Handler header; 2nd include to implement Code bumper to detect too long code of the Custom DPA Handler (modify the path according to your setup) 
#include "folder\to\DPAcustomHandler.h"
//############################################################################################
