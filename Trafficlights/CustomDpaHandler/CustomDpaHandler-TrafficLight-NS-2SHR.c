// *********************************************************************
//   Custom DPA Handler code - Trafficlight (2 shift register)		   *
// *********************************************************************
//
// Code was originally written by IQRF Tech s.r.o.
// Changes are made by Simen Stensås and Kjell Kirkaune, for ELE3391 Elektro prosjekt in the fall of 2019 at NTNU in Gjøvik.
// The unchanged version of this code can be found at downloaded IQRF resources folder (downloaded at IQRF's website as .zip).
//
// Code tested on: TR-72DA, on OS 4.03 and DPA 4.03. No guarantee to work on future versions, minor changes may be done.
//
// BE AWARE: This is for use with two shift registers (although this *can* be used).
// 			 For use with one shift register, use:
//			 CustomDpaHandler-TrafficLight-EW-1SHR.c
//
// *********************************************************************


// Default IQRF include (modify the path according to your setup)
#include "folder\to\IQRF.h"

// Default DPA header (modify the path according to your setup)
#include "folder\to\DPA.h"
// Default Custom DPA Handler header (modify the path according to your setup)
#include "folder\to\DPAcustomHandler.h"


// Port definitions
#define FOTGV			PORTA.0			// Fotgjengengerovergang venstre
#define FOTGH			PORTC.2			//    ------||------	 høyre

#define	CLK_START		LATC.5 = 1		// RC5 / PIN 8 - high
#define	CLK_STOP		LATC.5 = 0		// RC5 / PIN 8 - low

#define	STROBE_START	LATC.4 = 1		// RC4 / PIN 7 - high
#define	STROBE_STOP		LATC.4 = 0		// RC4 / PIN 7 - low

#define	DATA_START		LATC.3 = 1		// RC3 / PIN 6 - high
#define	DATA_STOP		LATC.3 = 0		// RC3 / PIN 6 - low



// Bit-shift function
void toggle(uns8 comb, uns8 loops);
void shift(uns8 data, uns8 data1);

int walkLeft;
int walkRight;


bit CustomDpaHandler()
//############################################################################################
{
  // Handler presence mark
  clrwdt();

  // Detect DPA event to handle (unused event handlers can be commented out or even deleted)
  switch ( GetDpaEvent() )
  {
	  
#ifdef DpaEvent_Interrupt
    // -------------------------------------------------
    case DpaEvent_Interrupt:
      // Do an extra quick background interrupt work
      // ! The time spent handling this event is critical.If there is no interrupt to handle return immediately otherwise keep the code as fast as possible.
      // ! Make sure the event is the 1st case in the main switch statement at the handler routine.This ensures that the event is handled as the 1st one.
      // ! It is desirable that this event is handled with immediate return even if it is not used by the custom handler because the Interrupt event is raised on every MCU interrupt and the “empty” return handler ensures the shortest possible interrupt routine response time.
      // ! Only global variables or local ones marked by static keyword can be used to allow reentrancy.
      // ! Make sure race condition does not occur when accessing those variables at other places.
      // ! Make sure( inspect.lst file generated by C compiler ) compiler does not create any hidden temporary local variable( occurs when using division, multiplication or bit shifts ) at the event handler code.The name of such variable is usually Cnumbercnt.
      // ! Do not call any OS functions except setINDFx().
      // ! Do not use any OS variables especially for writing access.
      // ! All above rules apply also to any other function being called from the event handler code, although calling any function from Interrupt event is not recommended because of additional MCU stack usage.

DpaHandleReturnTRUE:
      return TRUE;
#endif

	  // -------------------------------------------------
	case DpaEvent_Idle:
    {	
		uns16 btnCntV = 1000 + 1;
		uns16 btnCntH = 1000 + 1;
		
		while ( FOTGV && --btnCntV != 0 )
        {
			waitMS( 1 );
		}
		while ( FOTGH && --btnCntH != 0 )
        {
			waitMS( 1 );
		}
		
		// Button for left was pressed for at least 100ms
		if ( btnCntV < 1000 - 100 )
		{
			walkLeft = 1;

			clrwdt();
		}
		
		// Button for right was pressed for at least 100ms
		if ( btnCntH < 1000 - 100 )
		{
			walkRight = 1;

			clrwdt();
		}
		
		return Carry;
    }
    break;

	  // -------------------------------------------------
	case DpaEvent_Reset:
	
		// Button 1 (left)
		TRISA.0 = 1;			// PIN 1: MAIN		Register RA0 - (input)
		
		// Button 2 (right)
		TRISC.2 = 1;			// PIN 2: MAIN		Register RC2 - (input)

		// Clock
		TRISC.5 = 0;			// PIN 8: MAIN		Register RC5 - (output)
        TRISC.7 = 1;			// PIN 8: PARALLEL	Register RC7 - (input)
        
		// Strobe
		TRISC.4 = 0;			// PIN 7: MAIN		Register RC4 - (output)

        // Data
        TRISC.3 = 0;			// PIN 6: MAIN		Register RC3 - (output)
        
        CLK_STOP;				// Clk at zero
        DATA_STOP;				// Data at zero
        STROBE_STOP;			// Strobe at zero
        
        STROBE_START;			// Start strobe
        waitDelay(1);
        STROBE_STOP;			// Stop strobe
        waitDelay(1);

		break;

	  // -------------------------------------------------
	case DpaEvent_Init:
		// Do a one time initialization work before main loop starts
		
		break;

	  // -------------------------------------------------
	case DpaEvent_DpaRequest:
	  // Called to interpret DPA request for peripherals
	  // -------------------------------------------------
	  // Peripheral enumeration
	  if ( IsDpaEnumPeripheralsRequest() )
	  {
		_DpaMessage.EnumPeripheralsAnswer.UserPerNr = 1; // ?
		_DpaMessage.EnumPeripheralsAnswer.HWPID = 0x000F; // ????
		_DpaMessage.EnumPeripheralsAnswer.HWPIDver = 0xabcd; // ????
		goto DpaHandleReturnTRUE;
	  }
	  // -------------------------------------------------
	  // Get information about peripheral
	  else if ( IsDpaPeripheralInfoRequest() )
	  {
		if ( _PNUM == PNUM_USER + 1 ) // 21
		{
		  _DpaMessage.PeripheralInfoAnswer.PerT = PERIPHERAL_TYPE_USER_AREA; // PERIPHERAL_TYPE_?
		  _DpaMessage.PeripheralInfoAnswer.PerTE = PERIPHERAL_TYPE_EXTENDED_WRITE; // PERIPHERAL_TYPE_EXTENDED_?
		  _DpaMessage.PeripheralInfoAnswer.Par1 = 0; // ?
		  _DpaMessage.PeripheralInfoAnswer.Par2 = 0; // ?
		  goto DpaHandleReturnTRUE;
		}

		break;
	  }
	  // -------------------------------------------------
	  else
	  {
		// Handle peripheral command
		if ( _PNUM == PNUM_USER + 1 ) // 21
		{

            // Check command
			if ( _PCMD != 0 )
				DpaApiReturnPeripheralError( ERROR_PCMD );

			// Check data length
			if ( _DpaDataLength > 2 )
				DpaApiReturnPeripheralError( ERROR_DATA_LEN );
			
			toggle(_DpaMessage.Request.PData[0], _DpaMessage.Request.PData[1]);
			
			clrwdt();
			if( !(walkLeft && walkRight) )
			{
				if( walkLeft == 1 )
				{
					_DpaMessage.Response.PData[0] = 0x10;
				}
				else if( walkRight == 1 )
				{
					_DpaMessage.Response.PData[0] = 0x01;
				}
				else
				{
					_DpaMessage.Response.PData[0] = 0x00;
				}	
			}
			else
			{
				_DpaMessage.Response.PData[0] = 0x11;
			}
			
			_DpaDataLength = 1;
          
			goto DpaHandleReturnTRUE;
		}
	  }

	  break;
  }
DpaHandleReturnFALSE:
  return FALSE;
}


// Fill 74HC595 and strobe it out
void shift(uns8 data, uns8 data1) 
{	
	uns8 i;
	uns8 mask = 1;
	uns8 mask1 = 1;
	
	waitDelay(1);
	
	// Sending first 8 bit: XXXX XXXX .... ....
	for (i=0; i<8; i++)		// For each bit (8 total)
	{		
		if (data1 & mask1)	// Set data against the mask
			DATA_START;
		else
			DATA_STOP;
			
		waitDelay(1);		// Shift it 
		CLK_START;
		waitDelay(1);
		CLK_STOP;
		waitDelay(1);
		
		mask1 <<= 1;
	}
	
	// Sending second 8 bit: .... .... XXXX XXXX
	for (i=0; i<8; i++)		// For each bit (8 total)
	{		
		if (data & mask)	// Set data against the mask
			DATA_START;
		else
			DATA_STOP;
			
		waitDelay(1);		// Shift it 
		CLK_START;
		waitDelay(1);
		CLK_STOP;
		waitDelay(1);
		
		mask <<= 1;
	}
	
	STROBE_START;			// When all finished shifted, strobe it out/open latch
	waitDelay(1);
	STROBE_STOP;
	waitDelay(1);	
}



void toggle(uns8 comb, uns8 loops){
	clrwdt();
	uns8 data;
	uns8 data1;
	

	switch(comb)
	{
		// NS: North & south
		// EW: East & west
		
		// Turn all LEDs off
		case 0x00:
			data	= 0b00000000;
			data1	= 0b00000000;
			shift(data, data1);
			break;
		
		// Turn all LEDs on
		case 0x0A:
			data	= 0b11111111;
			data1	= 0b11111111;
			shift(data, data1);
			break;
		
		// NS: Green forward and left			EW: Red
		case 0x01:
			data 	= 0b10010001;
			data1	= 0b00000001;
			shift(data, data1);
			break;
			
		// NS: Yellow forward and left			EW: Red
		case 0x02:
			data 	= 0b01001001;
			data1	= 0b00000001;
			shift(data, data1);
			break;
			
		// NS: Red forward and left				EW: Red and yellow
		case 0x03:
			data 	= 0b00100101;
			data1	= 0b00000001;
			shift(data, data1);
			break;
			
		// NS: Red forward and left				EW: Green
		case 0x04:
			data 	= 0b00100101;
			data1	= 0b00000001;
			shift(data, data1);
			break;
			
		// NS: Red forward and left				EW: Yellow
		case 0x05:
			data 	= 0b00100101;
			data1	= 0b00000001;
			shift(data, data1);
			break;
			
		// NS: Red and yellow forward and left	EW: Red
		case 0x06:
			data 	= 0b01101101;
			data1	= 0b00000001;
			shift(data, data1);
			break;
			
		// NS: Green forward and left, red man left and green man right
		// EW: Red forward, green man left and red man right
		case 0x07:
			data 	= 0b10010010;
			data1	= 0b00000001;
			shift(data, data1);
			walkRight = 0;
			break;
		
		// NS: Red forward and left, green man left and red man right
		// EW: Green forward, red man left and green man right
		case 0x08:
			data 	= 0b00100101;
			data1	= 0b00000010;
			shift(data, data1);
			walkLeft = 0;
			break;
			
		// Blinking yellow all with all men no light
		case 0x09:
			uns8 i;
			for(i = 0x00; i < loops; i++)
			{
				data 	= 0b00000000;
				data1	= 0b00000000;
				shift(data, data1);
				waitMS(3500);
				clrwdt();				// Clear Watch Dog Timer
				
				data 	= 0b01001000;
				data1	= 0b00000000;
				shift(data, data1);
				waitMS(3500);
				clrwdt();
			}
			break;
		
		// Case 0xFF check if buttons are pressed
		case 0xFF:
			if(loops == 0xFF)
			{
				walkLeft = 0;
				walkRight = 0;
			}
			break;
		
		default:
			data	= 0b00000000;
			data1	= 0b00000000;
			shift(data, data1);
			break;
	}
}
//############################################################################################
// Default Custom DPA Handler header; 2nd include to implement Code bumper to detect too long code of the Custom DPA Handler (modify the path according to your setup) 
#include "folder\to\DPAcustomHandler.h"
//############################################################################################
